---
layout: homework
title: CSCI-UA.0480 - Homework #2
---

<div class="panel panel-default">
  <div class="panel-heading">Homework #2</div>
  <div class="panel-body" markdown="block">

# Higher Order Functions: Exercises and Processing Data - __Due Feb 18 at 11pm__

<!-->
<div markdown="block" class="img">
![dog](../resources/img/dog.gif)
</div>
-->

## Overview

### Description

__hoffy.js__ - Write a series of functions that demonstrate the use of the rest operator (or call/apply), and higher order functions

__analytic.js__, __tempAnalytic.js__, __readWeatherFs.js__, and __readWeatherUrl.js__ - Print out a report analyzing dog bite data. There are two parts to this:

* An initial version that works off of a local csv file
* A second version that works off of remote urls containing json (you can overwrite the previous part with this code)

See the [sample output](#hw02-sample) at the end of these instructions.

### Submission Process

You will be given access to a private repository on GitHub. It will contain unit tests, stub files for your code, a `package.json` and a `.eslintrc`

* The final version of your assignment should be in GitHub.
* __Push__ your changes to the homework repository on GitHub.

### (4 points) Make at Least 4 Commits

* Commit multiple times throughout your development process.
* Make at least 4 separate commits - (for example, one option may be to make one commit per part in the homework).

## Part 1 - Setup and Exercises

For this homework, you'll have files available in your repository, so you'll be cloning first.

The solutions to the following problems can go in the same file - __src/hoffy.js__:

### Setup

1. go to your github account...
2. find your repository: NetID-homework02 (note... this __should be your NetID__)
3. use the appropriate URL to run git clone

<pre><code data-trim contenteditable>git clone [YOUR REPO URL]</code></pre>

### Background Info

Implement functions that use JavaScript features such as:

* the rest operator
* the spread operator
* functions as arguments
* functions as return values
* decorators
* optionally call/apply/bind
* optionally arrow functions
* Array methods: 'filter', 'map', 'reduce'

Go through the functions in order; the concepts explored build off one-another, and the functions become more and more challenging to implement as you go on.

__Do not use__:

* `while` loops
* `for` loops
* `for ... in` loops
* `for ... of` loops
* `forEach` method .

__There will a small (-2) penalty every time one is used__. (Homework is 100 points total)


### Steps

1. prep...
    * create a `.gitignore` to ignore node_modules
	* create a `package.json` by using `npm init`
    * make sure that `mocha`, `chai`, and `eslint` are still installed (similar to previous assignment)
        <pre><code data-trim contenteditable>npm install -g mocha
npm install --save-dev eslint
npm install --save-dev chai
npm install --save-dev eslint-plugin-mocha
</code></pre>
    * you'll also need a few additional modules installed locally for the unit tests to run:
        * finally, install sinon and mocha-sinon locally for mocking `console.log` (these are for unit tests)
        * `npm install --save-dev sinon`
        * `npm install --save-dev mocha-sinon`
2. implement functions below in __hoffy.js__
3. make sure you export your functions as you implement them so that...
4. you can run tests as you develop these functions (again, the tests are included in the repository):
    `mocha tests/hoffy-test.js`
5. also remember to run eslint (there's a `.eslintrc` file included in the repository):
    `node_modules/.bin/eslint src/*`

### (40 points) Functions to Implement

### (-2 per while, for, forEach, for of, or for in loop used)

<hr>

### `longestString(s1, s2, s3 to sN)`

__Parameters:__

* `s1, s2, s3 to sN` - any number of string arguments

__Returns:__

* the longest string in the arguments passed in
* if no arguments are passed in, give back `undefined`

__Description:__

Goes through every string argument passed in and gives back the longest string. No error checking is required; you can assume that every argument is a string or no arguments are passed in at all. If there is a tie, return the argument that appears in the later position. If there are no arguments passed in, return `undefined`

HINTS:

* use `rest` parameters!
* try `reduce`

__Example:__

    longestString('foo', 'bar', 'bazzy', 'qux', 'quxx') // --> bazzy
    longestString('foo', 'bar', 'baz', 'qux') // --> qux
    longestString() // --> undefined

<hr>

### `maybe(fn)`

__Parameters:__

* `fn` - the function to be called 

__Returns:__

* a new `function` or `undefined` - the `function` calls the original function

__Description:__

`maybe` will take a function, `fn` and return an entirely new function that behaves mostly like the original function, `fn` passed in, but will return undefined if any `null` or `undefined` arguments are passed in to `fn`.

The new function will take the same arguments as the original function (`fn`). Consequently when the new function is called, it will use the arguments passed to it and call the old function and return the value that's returned from the old function. However, if any of the arguments are `undefined` or `null`, the old function is not called, and `undefined` is returned instead. You can think of it as a way of calling the old function only if all of the arguments are not `null` or not `undefined`.


__Example:__

    function createFullName(firstName, lastName) {
        return `${firstName} ${lastName}`; 
    }
    maybe(createFullName)('Frederick', 'Functionstein'); // Frederick Functionstein
    maybe(createFullName)(null, 'Functionstein');        // undefined
    maybe(createFullName)('Freddy', undefined);          // undefined 

<hr>

### `filterWith(fn)`

__Parameters:__

* `fn` - a _callback_ function that takes in a single argument and returns a value (it will eventually operate on every element in an array)

__Returns:__

* `function` - a function that...
    * has 1 parameter, an `Array`
    * returns a new Array where only elements that cause `fn` to return `true` are present (all other elements from the old Array are not included)

__Description:__

This is different from regular filter. The regular version of filter immediately calls the callback function on every element in an Array to return a new Array of filtered elements. `filterWith`, on the other hand, gives back a function rather than executing the callback immediately (think of the difference between bind and call/apply). `filterWith` is basically a function that turns another function into a filtering function (a function that works on Arrays). 

__Example:__

    // original even function that works on Numbers
    function even(n) {return n % 2 === 0;} 

    // create a 'filter' version of the square function
    filterWithEven = filterWith(even); 

    // now square can work on Arrays of Numbers!
    console.log(filterWithEven([1, 2, 3, 4])); // [2, 4]    
    
    const nums = [1, NaN, 3, NaN, NaN, 6, 7];
    const filterNaN = filterWith(n => !isNaN(n));
    console.log(filterNaN(nums)); // [1, 3, 6, 7]

<hr>


### `steppedForEach(arr, fn, step)`

__Parameters:__

* `arr` - the array containing potential arguments to the function `fn`
* `fn` - the function to be called repeatedly
* `n` - the number elements to be consumed from the array to be used as arguments to `fn`

__Returns:__

* `undefined` (no return value)

__Description:__

Calls the function `fn` using every `step` number of elements from the `Array`, `arr`, as arguments to `fn`. For example, if `step` were 3, then `fn` would be called with the first 3 elements of `arr` each as a positional argument. `fn` will be called again with the next 3 arguments. `fn` will continue to be called until there are no more elements to use as arguments from `arr`. If the last group of arguments is less than `step` call the function `fn` with whatever arguments are left (see example below)

HINT: to adhere to the restrictions regarding use of for, for of, forEach, while, etc. ... it might be useful to think of a way to implement this function recursivelu

__Example:__

	steppedForEach([1, 2, 3, 4, 5, 6], (a, b, c) => console.log('' + a + b + c),  3);
	/* 
	note that arrow function is called twice, each time with 3 elements from arr:
	123
	456
	*/
	steppedForEach([1, 2, 3, 4, 5, 6, 7], (a, b, c) => console.log('' + a + b + c),  3);
	/*
	in this case, the arrow function is called 3 times, but the last time, only one
	argument is passed in, 7 (there are no more elements after that)
	123
	456
	7undefinedundefined
	*/

<hr>

### `constrainDecorator(fn, min, max)`

__Parameters:__

* `fn` - the function to modify (_decorate_)
* `min` - the minimum value that `fn` can return
* `max` - the maximum value that `fn` can return

__Returns:__

* `function` - a function that...
    * does the same thing as the original function, `fn` (that is, it calls the original function)
    * accepts the same number of arguments as the original function, `fn`
    * the return value is the return value of `fn`, unless it is less than or greater than the `min` and `max`, in which case it returns `min` or `max` respectively

__Description:__

This function is a decorator. [See the slides on the decorator pattern](../slides/js/higher-order-functions-continued.html) for background information. It builds on top of the example in the slides by actually _modifying_ the return value of the original function.

This function wraps the function `fn` in another function so that operations can be performed before and after the original function `fn` is called. This can be used to modify incoming arguments, modify the return value, or do any other task before or after the function call. Again, we'll be modifying the return value in this case.

This particular decorator function constrains the result of the function being wrapped, `fn` so that its return value fits between `min` and `max` inclusive. If these are omitted from the original outer function, then the newly returned function will just return the value unmodified. You can assume that the return value of `fn` is `Number` (you do not have to deal with other types).


__Example:__

    // creates a new function from the built-in function, parseInt
    // the new function is the same thing as parseInt, but it constrains
    // the return value to a value between min and max (inclusive)
    const constrainedParseInt = constrainDecorator(parseInt, -10, 10);

    // still works like the original parseInt
    constrainedParseInt("7") // --> 7
    constrainedParseInt("-10")) // --> -10

    // but if the return value is less than min or greater than max
    // it returns min or max respectively
    constrainedParseInt("-12") // --> -10
    constrainedParseInt("12")) // --> 10

    // however, if either min or max are missing, then the new function
    // returns the result of fn unmodified regardless of value
    var constrainedParseInt2 = constrainDecorator(parseInt);
    constrainedParseInt2("-12") // --> -12

<hr>

### `limitCallsDecorator(fn, n)`

__Parameters:__

* `fn` - the function to modify (_decorate_)
* `n` - the number of times that `fn` is allowed to be called

__Returns:__

* `function` - a function that...
    * does the same thing as the original function, `fn` (that is, it calls the original function)
    * but can only be called `n` times
    * after the `n`th call, the original function, `fn` will not be called, and the return value will always be `undefined`

__Description:__

This is the culmination of all of the concepts from the previous functions. However, instead of just reading from a variable that's available through the closure, you'll use it to keep track of the number of times that a function is called... and prevent the function from being called again if it goes over the `max` number of allowed function calls. Here are the steps you'll go through to implement this:

1. create your decorator (function)
2. create a local variable to keep track of the number of calls
3. create an inner function to return
    * the inner function will check if the number of calls is less than the max number of allowed calls
    * if it's still under max, call the function, `fn` (allow all arguments to be passed), return the return value of calling `fn`, and increment the number of calls
    * if it's over max, just return `undefined` immediately without calling the original function

__Example:__

    const = limitedParseInt = limitCallsDecorator(parseInt, 3);
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> 423
    limitedParseInt("423") // --> undefined


<hr>

### `bundleArgs(fn, args1, args2 to argsn)`

__Parameters:__

* `fn` - the function to get args bundled with it
* `args1, args2 to  argsn` - any numbers of args that will automatically get filled in when the output function is used


__Returns:__

* `function` - a version of the original `fn` that can take any number of arguments, but when used, will use the `args1, args2 to argsn` as the first parameters to `fn`, filling in the new arguments afterwards

__Description:__

Suppose you're using the same function all the time, with nearly the same arguments every time: wouldn't it be great to have a quick way to make an alternate version of your function where your favorite arguments come pre-filled?

Of course, `bind`, already does this for us, so don't take the easy way out and use `bind`. Implement this function __without bind__!

__Example:__

    // example, you have a function that surrounds text with other text
    function surroundText(surrounding, text) {
      return [surrounding, text, surrounding].join(" ")
    }

    // but you know you're going to use it for one thing only
    const makeCool = bundleArgs(surroundText, "~x~X~x~")

    // save yourself some time
    console.log(makeCool("i guess")) // ~x~X~x~ i guess ~x~X~x~

	// again w/ leftovers
	function repeatLetter(letter, times) {
		Array(times).fill(letter).join('');
	}

	// fix 1 of 2 arguments to 'r'
	rrrrrollWithIt = bundleArgs(repeatLetter, 'r');

	// resulting function has only one arg now
	rrrrrollWithIt(10) // rrrrrrrrrr
<hr>


### `sequence(fn1, fn2, to fnN)`

__Parameters:__

* `fn1, fn2, to fnN` - a bunch of functions

__Returns:__

* `function` - a function that will pass it's arguments to `fn1`, take the output of `fn1` and use it as the argument to `fn2`, then take the output of `fn2` and use it for `fn3`, and then... etc


__Description:__

A handy utility for automating the writing of code that's just calling functions to pass their arguments to other functions. You can assume that each function passed in only takes one argument.

HINT: it's kind of like _summing_ or _composing_ the functionality of a bunch of functions together

__Example:__


    // let's say you have some pretty procedural functions
    function superCamelCase(s) {
      return s
        .split("")
        .map((c, i) => (i % 2 == 0 ? c.toUpperCase() : c.toLowerCase()))
        .join("")
    }

    function spaceText(s) {
      return s.split("").join(" ")
    }

    function addStyle(s) {
      return "~~~ " + s + " ~~~"
    }

    // you want to make a playlist of them
    const aestheticFmtPipeline = sequence(
      superCamelCase,
      spaceText,
      addStyle
    )

    console.log(aestheticFmtPipeline("hello world")) // ~~~ H e L l O   W o R l D ~~~

    function makeVertical(s) {
      return s.split("").join("\n")
    }

    // playlists of playlists of functions
    const tallAestheticFmt = sequence(aestheticFmtPipeline, makeVertical)

    console.log(tallAestheticFmt("goodbye world"))
    /*
    ~
    ~
    ~

    G

    o

    O

    d

    B

    y

    E



    W

    o

    R

    l

    D

    ~
    ~
    ~
    */

### Test, Lint and Commit

Once you're finished with your functions, remember to:

1. make sure all tests are passing
2. make sure that eslint shows no errors
3. commit and push your code!


## Part 2 - Weather Analysis

In this part, you'll work with a dataset of Hourly weather data for 30 US & Canadian Cities + 6 Israeli Cities. You'll use higher order functions to analyze the data;

The data is a Kaggle Challenge which you can access via [https://www.kaggle.com/selfishgene/historical-hourly-weather-data](https://www.kaggle.com/selfishgene/historical-hourly-weather-data).

You'll work with the following two files for this part: 

1. `tempAnalytic.js` to create a function called `analyzeTemperature`
    * the function will take an `Array` of objects with each object representing the temperature of 36 cities
    * the function should be exported so that it can be accessed when this filed is used as a module through `require`
2. `readWeatherFs.js` to read in a file containing JSON data. The JSON data is a list of hourly temperatures per city. Use the `analyzeTemperature` function from the `tempAnalytic.js` above to create a report (Note: you can assume there are no missing values, `NaN` or null in the data. In other words, no data cleansing or validation is necessary.)

### Importing Data

* Download the data by going to [https://data.cityofnewyork.us/Health/DOHMH-Dog-Bite-Data/rsgh-akpg](https://data.cityofnewyork.us/Health/DOHMH-Dog-Bite-Data/rsgh-akpg) and name the folder `historical-hourly-weather-data-json`
    * place the folder in the root folder of your repository
    * `historical-hourly-weather-data-json` should contain a `temperature.json` file
* Start by reading in the file using `fs.readFile`
    * ⚠️⚠️⚠️ __use a relative path so that grader's can grade on their computer__
    * make sure that the `fs` module is brought in using `require`, then call the function)
    * __do not use readFileSync__
* See the docs on `fs.readFile` (HINT: make sure you specify `utf8` as the second argument)
* Also remember that the data read in the memory is a `JSON string`
* The file that you read in contains an array of hourly temperature data:
    * each object in the array is an hourly temperature of 36 cities.
    * the first property in the object is `datetime` formatted as `YYYY-MM-dd HH:mm:ss`
    * following properties are `city name` with value of `temperature` in *Kevlin Scale*
* Find a way to read in and convert the Kevlin scale to Fahrenheit which is more commonly used:
    * The formula is `T(F) = T(K) * 1.8 - 459.67` [https://www.rapidtables.com/convert/temperature/how-kelvin-to-fahrenheit.html](https://www.rapidtables.com/convert/temperature/how-kelvin-to-fahrenheit.html)
    * note that the goal of this assignment is to work with higher order functions, so memory efficiency does not need to be taken into consideration
* All of your parsing can only be done within the callback function (or the function to be called once data is read from the file) that you supply to `fs.readFile`
* **Print the first ten lines of temperature in New York with the format using template literals**

```javascript=
// Format
At ${time}, the temperature in NY is ${degree in Fahrenheit} (F)

// Example
At 2012-10-01 13:00:00, the temperature in NY is 59.13 (F)
```

* Later, you will be supplying this `Array` to the `analyzeTemperature` function that you create in `tempAnalytic.js` to generate a report.

### Folder Structure

For this part, your homework folder structure looks like:

```
├── historical-hourly-weather-data-json
│   └── temperature.json
└── src
    ├── tempAnalytic.js
    └── readWeatherFs.js 
```
Note: this is the basic strcuture, you may create extra `.js` for modularity of the folder.

### Examining the Data
Assuming that your parsed data is in a variable called `weatherData` and `weatherData` will be an `Array` of JSON objects.

Below is one object of the JSON array in your assignment. All temperatures are in degree of Kelvin scale.

```
{
    "datetime":"2012-10-01 13:00:00",
    "Vancouver":284.63,
    "Portland":282.08,
    "San Francisco":289.48,
    "Denver":284.61,
    "San Antonio":289.29,
    ...
    "Tel Aviv District":305.47,
    "Eilat":310.58,
    "Haifa":304.4,
    "Nahariyya":304.4,
    "Jerusalem":303.5
}
```

### Analytics

#### The `analyzeTemperature` Function

This is the function that you will create in `tempAnalytic.js` where it performs basic data analytic and output the analysis string to `stdout`. You are expected to use as much higher order function as you can to build this function.

### `analyzeTemperature (weatherData)`

__Parameters:__

* `weatherData` - an `Array` of objects, with each object representing an hourly temperature for each of 36 cities.

__Returns:__

* void. the analysis strings are output to `stdout`. (simply use `console.log`)

__Description:__

This function will generate a report based on the `Array` of objects passed in. The report will contain the average temperature of different cities over the entire time series, or a specific year, or a particular season. It also includes reporting the coldest (warmest) date and figuring out the top ten coldest (warmest) cities in the dataset.

### Implementation Requirements

When creating your report in `analyzeTemperature`, for each required data analytic, you must use all of the following Array methods at least once each in your program:

1. `forEach`
2. `filter`
3. `map`
4. `reduce`
5. Other functions that may help you apply higher order functions
6. There will be a small penalty for each one not used (-2).
7. Note: try not to modify the input data during executing your function. Usually the input should be read-only and if you would like to overwrite it, creating an copy would be fine. (In this assignment, the size of data is relatively small)
	
### Problem Overview

Your report will use the data passed in to determine:

1. First 10 lines of Temperature in NY
2. The mean temperature in San Diego
3. The coldest, warmest time and temperature in New York
4. Top 10 cities with coldest and warmest mean temperature
5. The average temperature over spring 2013 in New York

See the following details...

You are going to create a function. Note that after the output of each problem, print an empty line to separate each section.

```javascript=
// tempAnalytic.js

function analyzeTemperature (weatherData) {
    // Implement Head 10 lines of Temperature in NY

    console.log('');
    // Implement The mean temperature in San Diego

    ...

    // Implement The average temperature over spring 2013 in New York
    
    console.log('');
}
```

### First 10 lines of Temperature in NY

This is to test if you convert the temperature scale in the callback correctly and display floating point numbers in a certain format (when you are creating a dashboard, this matters). Also when doing data analytic, the first step is to peek a small portion of data. (like head function in pandas dataframe)

The output format and example are listed below:

Format: Print all decimal numbers with 2 digits after decimal point
```
At `YYYY-MM-dd HH:mm:ss`, the temperature in NY is `xx.xx` (F)
```
HINT: use `toFixed(n)` or `toPrecision(n)`. what's the difference between them?

Example:
```
First 10 lines of Temperature in NY:
At 2012-10-01 13:00:00, the temperature in NY is 59.13 (F)
...
```
Note: regular for loop is fine, but try to use higher order functions

### The mean temperature in San Diego

This is to test if you can composite more than one higher order functions.

Format: Print all decimal numbers with 2 digits after decimal point
```
The mean temperature in San Diego is: xx.xx (F)
```

### The coldest, warmest time and temperature in New York

Find the top ten coldest, warmest date and temperature and output in the following format

Format: Print all decimal numbers with 2 digits after decimal point
```
The coldest time in New York is: `YYYY-MM-dd HH:mm:ss`
The lowest temperature is: xx.xx (F)
The warmest time in New York is: `YYYY-MM-dd HH:mm:ss`
The highest temperature is: xx.xx (F)
```

### Top 10 Cities with coldest and warmest mean temperature

Format: Print all decimal numbers with 2 digits after decimal point

```
Top 10 Cities with highest mean temperature
Tel Aviv District: 70.45 (F)
Jacksonville: 70.24 (F)

Top 10 Cities with lowest mean temperature
Toronto: 47.96 (F)
Denver: 49.54 (F)
```
Note: use as much higher order functions as you can.

HINT: to get the mean of a sequence of values, you will convert an array to a single number. you should also consider `weatherData` is an array of objects (conceptually a 2 dimensional array), how can you do achieve this applying a higher order function?

HINT: what is the simplest way to rank a sequence of data?

### The average temperature over spring 2013 in New York

This is to help you get a sense of how to use `date` in Javascript. Please refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
 and look at how to instantiate a date object. More detail steps are listed.

1. Let's define the spring in NY is from *Feburary* to *April*.
2. The date string in the dataset is represented as `'YYYY-MM-dd HH:mm:ss'`. This is compared based on string instead of date. So **parse** this date string to date object and fetch `year`, `month`, `day`, `hour`, `minute`, and `second` (write your own parser for date string and instantiate a [date object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)), you may create a function `stringToDate(dateStr)` that returns a date object
3. Until now, you can set up a range to retrieve records during spring 2013. Hint: by using `getFullYear()`, `getMonth()` of the date object. (Again, try to use higher order functions)
4. Then compute the mean temperature of NY in spring 2013

Format: Print all decimal numbers with 2 digits after decimal point

```
The average temperature over spring 2013 in New York is: **.** (F)
```
HINT: be careful to the numeric representation of month returned from `getMonth()`.

### Return Value

Your function can return void (i.e., you don't need to return any value, just make sure you output the result strings in `stdout` using `console.log`)

### Calling analyzeTemperature

Now that you've finished your function, you can try to call it on your data from `readWeatherFs.js`

1. In `readWeatherFs.js`: require the module that you created (`tempAnalytic.js`).
2. Use readFile to read `temperature.json` in the folder `historical-hourly-weather-data-json`
3. Call `analyzeTemperature()` in the callback of `fs.readFile`
4. Print out the report.
5. You can compare your output with the example output below (See bottom how to compare your output with the below example)

```
The first 10 lines of Temperature in NY:
At 2012-10-01 13:00:00, the temperature in NY is 59.13 (F)
At 2012-10-01 14:00:00, the temperature in NY is 59.18 (F)
At 2012-10-01 15:00:00, the temperature in NY is 59.32 (F)
At 2012-10-01 16:00:00, the temperature in NY is 59.46 (F)
At 2012-10-01 17:00:00, the temperature in NY is 59.60 (F)
At 2012-10-01 18:00:00, the temperature in NY is 59.75 (F)
At 2012-10-01 19:00:00, the temperature in NY is 59.89 (F)
At 2012-10-01 20:00:00, the temperature in NY is 60.03 (F)
At 2012-10-01 21:00:00, the temperature in NY is 60.17 (F)
At 2012-10-01 22:00:00, the temperature in NY is 60.32 (F)
At 2012-10-01 23:00:00, the temperature in NY is 60.46 (F)

The mean temperature in San Diego is: 62.72 (F)

The coldest time in New York is: 2015-02-21 08:00:00
The lowest temperature is: -8.28 (F)
The warmest time in New York is: 2013-07-19 17:00:00
The highest temperature is: 98.76 (F)

Top 10 Cities with highest mean temperature
Miami: 77.06 (F)
Eilat: 74.03 (F)
Phoenix: 72.29 (F)
Haifa: 71.81 (F)
Tel Aviv District: 70.45 (F)
Jacksonville: 70.24 (F)
Houston: 69.97 (F)
Nahariyya: 69.70 (F)
San Antonio: 69.23 (F)
Jerusalem: 68.06 (F)
Las Vegas: 66.79 (F)
Top 10 Cities with lowest mean temperature
Montreal: 45.11 (F)
Minneapolis: 45.81 (F)
Toronto: 47.96 (F)
Denver: 49.54 (F)
Detroit: 49.84 (F)
Chicago: 50.55 (F)
Boston: 51.25 (F)
Vancouver: 51.28 (F)
Pittsburgh: 51.80 (F)
Seattle: 52.39 (F)
Indianapolis: 53.11 (F)

The average temperature over spring 2013 in New York is: 41.10 (F)

```

Lint, commit and push your code; the next part will make modifications to this existing code (you can overwrite your work in this file directly for the next part).

## Part 3 - Retrieve JSON from URL

### Setup for Retrieving JSON

In this part, you'll be setting up your project to work with JSON data from a url and issue request in a particular order.

### Context (Optional)
Below is to provide you a context, you can skip this which doesn't affect the implementation of this problem.

In the previous part, you only work with one dataset (resource). But in reality, you may need to work with multiple datasets from different resources. Sometimes you need one information in one dataset you just retrieved to help you identify target document you need to retrieve from other resources. For example, you may have initial access to a resource called `user`. Now you want to retrieve an information `price` of a user's order in a different resource called `order`. In order to retrieve the correct price for specific user's order, you must have `user_id` (which resides in `user`) in hand, then request `price` (which resides in `order`) by matching `user_id` with records in `order`. Now, the **order of retrieval** here matters, where you must receive the response from `user`, then request `order` and send `user_id` along with the request. 

In this part of homework, we are trying to simulate this to help you get a better understanding of this process using Node.

### Retrieve and Process JSON 

After completed the previous part, you now have better understanding of `temperature.json`. But a weather analyst, also wants to analyze hourly wind speed and air pressure as well. The url of these datasets are inside the previous resources you retrieved. In order to retrieve all datasets and perform analysis on them, you have to follow below steps.

1. You are given an initial url which identifies the `temperature-resource.json`.
2. In the `temperature-resource.json`, there is an additional property called `next`, which helps you identify the next dataset `wind_speed-resource.json`.
3. The next dataset to the wind speed is `pressure-resource.json`.
4. As long as all these datasets are well prepared, perfrom similar analytics using the function you created in the previous part (you only need logics of problem 4 and 5 in the previous part).

### Data

The `temperature-resource.json` you fetched using request from given url looks like below. **Note that the request url you are using is `ROOT_URL + /temperature-resource.json`. The ROOT_URL will be given.** After the dataset return from remote, you can use the `next` property to construct next url then fetch the following dataset. The descriptions of properties in this data are listed below.

1. `next`: contains the next resource name (not the exact url)
2. `response`: JSON array and each object contains weather data of each of 36 cities (same as the `temperature.json` in Part 2)
```
{
    "next": "wind_speed-resource",
    "response": [{"datetime": "2012-10-01 13:00:00",
                  "Vancouver": 284.63,
                  "Portland":  282.08,
                  "San Francisco": 289.48,
                  "Seattle": 281.8,
                  "Los Angeles": 291.87,
                  "San Diego": 291.53,
                  "Las Vegas": 293.41,
                  "Phoenix": 296.6,
                  "Albuquerque": 285.12,
                  ...
                 }, {
                     ...
                 },
                 ...
                ]
}
```

### Implementation Detail

1. Install the requests library in your project's root folder: `npm install --save request` (similar to installing `readline-sync` in the previous assignment)
2. Create a new file `readWeatherUrl.js`
3. Add the `request` module to the beginning of `readWeatherUrl.js` using `require`
4. [Read the documentation](https://github.com/mikeal/request) to see how to use the requests module (or see the [slides](../slides/js/js-node-npm-debug-git.html#/6))
	* Notice that the data is only available within the callback that you pass in to calling `request` (much like using readFile)
	* Again, a __callback__ is a function passed as an argument to another function... the callback will be invoked / executed at a later time, when some event is triggered
	* In the case of `request`, it's the function that you pass in as the 2nd argument
5. Instead, use request to download the first json file (url given through piazza)
6. Notice that the json file has two fields `response` and `next`
	* `response` is a list of objects, with each object containing temperatures of each of 36 cities
	* `next` is the name (without extension) of the next file to retrieve
7. Create a file `analytic.js` and export a function called `analytic`
8. Copy and paste the analytic code for `Top 10 Cities with coldest and warmest mean temperature` and `The average temperature over spring 2013 in New York` on `analytic.js`
9. Now this code is going to accept not only a list of objects containing `temperature`, but also `wind speed` and `pressure`.
10. The function signature should be `analytic(weatherData, variable, unit)` as shown below:
    ```javascript=
    // analytic.js

    function analytic(weatherData, variable, unit) {
        /* params:
         *   weatherData: an array of objects (temperature, wind speed, pressure)
         *   variable: exactly 'temperature', 'wind speed', 'pressure'
         *   unit: 'F' for temperature, 'm/s' for wind speed, 'hpa' for pressure
         */

         // COPY AND PASTE YOUR CODE IN PART 2 BELOW AND DO SOME GENERALIZATIONS
    }
    
    ```
    The reason behind this is to create a generalized method that can report different weather variables (not only temperature).
11. Note: you can imagine that there will be a sequence of callbacks and you need to deal with different variable scopes. Try to avoid making your code **callback hell** by designing your functions properly.

### Folder Structure

Until this part, your homework folder structure looks like:

```
├── historical-hourly-weather-data-json
│   └── temperature.json
└── src
    ├── readWeatherFs.js
    ├── readWeatherUrl.js.js
    ├── analytic.js
    └── tempAnalytic.js
```
Note: this is the basic strcuture, you may create extra `.js` for modularity of the folder.

### Result

```
Top 10 Cities with highest mean temperature
Miami: 75.73 (F)
Eilat: 74.73 (F)
Phoenix: 73.03 (F)
Tel Aviv District: 70.67 (F)
Houston: 70.10 (F)
Haifa: 70.01 (F)
Nahariyya: 69.39 (F)
Beersheba: 69.12 (F)
San Antonio: 69.04 (F)
Jacksonville: 68.88 (F)
Las Vegas: 68.48 (F)
Top 10 Cities with lowest mean temperature
Minneapolis: 44.82 (F)
Montreal: 45.29 (F)
Toronto: 48.10 (F)
Denver: 49.79 (F)
Detroit: 50.16 (F)
Chicago: 50.63 (F)
Boston: 51.07 (F)
Vancouver: 51.08 (F)
Pittsburgh: 51.18 (F)
Seattle: 51.80 (F)
Portland: 52.84 (F)

The average temperature over spring 2013 in New York is: 35.22 (F)

Top 10 Cities with highest mean wind speed
Eilat: 3.68 (m/s)
New York: 3.42 (m/s)
Haifa: 3.31 (m/s)
Indianapolis: 3.29 (m/s)
Chicago: 3.28 (m/s)
Toronto: 3.28 (m/s)
Montreal: 3.27 (m/s)
Minneapolis: 3.17 (m/s)
Dallas: 3.14 (m/s)
Kansas City: 3.02 (m/s)
Nahariyya: 2.99 (m/s)
Top 10 Cities with lowest mean wind speed
Los Angeles: 0.76 (m/s)
Phoenix: 1.12 (m/s)
Vancouver: 1.47 (m/s)
San Diego: 1.68 (m/s)
Jerusalem: 1.69 (m/s)
Portland: 1.83 (m/s)
Seattle: 1.90 (m/s)
Atlanta: 1.97 (m/s)
Charlotte: 2.03 (m/s)
Denver: 2.11 (m/s)
Beersheba: 2.21 (m/s)

The average wind speed over spring 2013 in New York is: 4.45 (m/s)

Top 10 Cities with highest mean pressure
Seattle: 1023.78 (hpa)
Vancouver: 1020.56 (hpa)
Haifa: 1019.73 (hpa)
Atlanta: 1018.95 (hpa)
Nahariyya: 1018.71 (hpa)
Miami: 1018.66 (hpa)
Jacksonville: 1018.48 (hpa)
Charlotte: 1018.45 (hpa)
Philadelphia: 1018.45 (hpa)
Nashville: 1017.96 (hpa)
Portland: 1017.75 (hpa)
Top 10 Cities with lowest mean pressure
Albuquerque: 1000.25 (hpa)
Beersheba: 1000.38 (hpa)
Jerusalem: 1002.92 (hpa)
Kansas City: 1005.83 (hpa)
Denver: 1007.31 (hpa)
Phoenix: 1008.43 (hpa)
Eilat: 1008.82 (hpa)
Las Vegas: 1012.44 (hpa)
New York: 1013.11 (hpa)
Tel Aviv District: 1013.51 (hpa)
Los Angeles: 1014.68 (hpa)

The average pressure over spring 2013 in New York is: 1019.81 (hpa)

```

### Testing for Part 2 and Part 3

You can copy and paste the provided result to a text file. Then redirect the output from node to another file, and use a Linux command `diff`. For example:

```
node part3.js > file2.txt
diff file1.txt file2.txt
```
</div>

</div>
