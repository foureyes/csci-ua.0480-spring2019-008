---
layout: homework
title: CSCI-UA.0480 - Homework #4
---

<style>
h1.warning {
	background-color: #eaa;
}
</style>
<div class="panel panel-default">
	<div class="panel-heading">Homework #4</div>
	<div class="panel-body" markdown="block">

# Express Make a Site That Looks Like a Commandline Console!  - __Due Wednesday, March 27th__, by 11PM

## Overview

### Description

Create a site that provides a web, form-based "Linux Shell" supporting basic commands that can be performed on a remote "fake" in-memory file system. In this homework you'll be working with:

* Serving static files
* Middleware
* Handling forms, both GET and POST
* Templating
* A JSON Representation of a Simple File System 

You'll be creating 2 pages:

* __home__ - <code>/</code>: a basic form that allows users to select a distribution of Linux Operating System.
* __vfs (virtual file system)__ - <code>/vfs</code>: a page that allows users to manipulate resources of a virtual file system by submitting Linux commands through two forms and see system states returned from the server (This is an in-memory file system).

Your directory layout should look similar with the following __once you're done with the assignment__:

<pre><code data-trim contenteditable>
├── app.js
├── package-lock.json
├── package.json
├── public
│   ├── css
│   │   └── style.css
│   └── img
│       ├── redhat.png
│       ├── debian.png
│       └── ubuntu.jpg
├── views
│   ├── layout.hbs
│   ├── directory.hbs
│   ├── open.hbs
│   ├── terminal.hbs
│   └── index.hbs
│
└── vfs
    ├── initFs.js
    └── FileSystem.js
</code></pre>

In the __views__ directory, you are not required to have the same files as above. If you'd like, you can use template partials to reduce redundant markup. This was not covered in class, but you can check out the [documentation on partials in the hbs module's npm page](https://www.npmjs.com/package/hbs#helpers-and-partials).

The focus of this homework is the implementation of GET and POST forms and the creation of a fake / _virtual_ file system. While using css is required, the amount and complexity of actual styling is your discretion. __The assignment is not graded on aesthetics__, so complex styles are not required. There are suggestions on styling, __but you are free to dictate the look and feel of site__ (by using css and images as _static files_ in `public`).

### Example Interaction

<div class="img">
<!--![interaction](../resources/img/hw04-asciidiary-mainexample.gif)-->
<img width="75%" src="../resources/img/hw04-file-system-example.gif">

</div>

### Submission Process

1. You will be given access to a private repository on GitHub
2. The final version of your assignment should be in GitHub
3. __Push__ your changes to the homework repository on GitHub by the due date.

### (4 points) Make at Least 4 Commits

* Commit multiple times throughout your development process.
* Make at least 4 separate commits - (for example, one option may be to make one commit per part in the homework).

## Part 1 - Setup

###  Installing Dependencies

* create a <code>package.json</code>
* __install__ the following __dependencies__ (make sure you use the <code>--save</code> option)
	* <code>express</code>
	* <code>hbs</code>
    * <code>moment</code>


###  .gitignore

* create a <code>.gitignore</code>
* ignore the following files:
	* <code>node_modules</code>
	* any other files that aren't relevant to the project... for example
        * <code>.DS_Store</code> if you're on OSX
        * <code>.swp</code> if you use vim as your editor
        * etc.

### linting

* an eslint configuration file (for example `.eslintrc.json`) should be in the root directory (or copy one from a previous project if it doesn't exist)
* make sure that any global linting tools are installed (`eslint`)
* periodically lint your program as you work

## Part 2 - A Fake / _Virtual_ Remote File System

### Overview

In this homework, you'll create an Express application that displays a background image of three Linux distributions (or some styling of your choice), and a shell-like interface implemented by HTML forms. Users send shell commands via GET and POST requests through the forms to a server. The server dispatches requests to operate on a in-memory virtual file system using these commands, and responds with the state of the virtual file system.

The file system will be implemented using a nested JSON object; it will represent the state of the virtual file system. Additionally, use an ES6 class to encapsulate the data and interact with the virtual file system represented by the data.

You can assume that your application will process http requests serially; you don't have to handle any race conditions.

This part contains four major components.

1. Serving static files
2. An Express Server
3. The Virtual File System
4. Templating

###  Serving Static Files

In this section, you'll work with the built-in Express static middleware to serve images and css. __Again, you are free to have your own styles, as long as they are served through `express.satatic` / the `public` folder__. The following description is based on the reference solution's styles.

In the demo, the static files include css for basic styling and desktop images of 3 different Linux operating systems: Ubuntu, Debian and Redhat.

* To serve static files, create the following directory structure in your project's root directory
	* <code>public</code>
	* <code>public/css</code>
	* <code>public/img</code>
* Add a blank css file in <code>public/css/style.css</code>
* Add images that you'll use for styling
	* You can use your own images...
	* Or use a screen capture of various desktops:
		* [Ubuntu](../../resources/img/hw04-ubuntu.jpg)
		* [Debian](../../resources/img/hw04-debian.png)
		* [RedHat](../../resources/img/hw04-redhat.png).
		* (You can stretch, tile, etc. to fill the background if you like, as these images are fixed dimensions)
* You'll test these static assets later on


### File System

In this section, you'll mimic a Linux file system through JavaScript.

In Linux, The file system is implemented as a tree. The root of this tree is the root directory and is denoted as <code>/</code>. Each node in this tree represents a file. If a node is a leaf, then it is a file, otherwise it is a directory (Note: in Linux, a file can be a file or a directory). Each node stores metadata about the directory / file. The children of a node is another nested file system tree. To search for a file, perform tree traversal to find the node. 

#### Commands

Commands will be chosen and issued through forms on an html page. The forms will send requests to the server, and the server will read or modify the virtual file system based on the form data. The commands you'll implement include:

1. <code>ls</code>
    * **Arguments**: <code>[path/to/dir]</code>
    * **Options**: <code>-l</code>show file metadata <code>.</code>
    * **Output**: shows a list of all files in the directory specified by argument
		* by default, only the names of all the files in the directory are listed 
			* the names are listed in the order that they appear in the directory node
			* (this is different from the _actual_ behavior of `ls` which sorts by name - _kind_ of)
		* however, with the -l option:
        	* each line in the resulting listing shows information about files or directories contained in the directory
			* the information is file / directory metadata: <code>file_type (d or -), permissions, number of hard links, owner, group, size, last-modified data, file name</code>
        	* an example directory is: <code>drwxr--r-- 1 root root 6 Feb 25 11:20 bin</code>
        	* An example file is: <code>-rwxr--r-- 1 root root 6 Feb 25 11:20 file.txt</code>
        * for more information, please refer to [ls](https://en.wikipedia.org/wiki/Ls).
2. <code>tree</code>
    * **Arguments**: <code>[path/to/dir]</code>
    * **Options**: <code>None</code>
    * **Output**:
        * displays the file system tree under <code>[path/to/dir]</code>
		* names of files / directories are nested underneath eachother through indentation
3. <code>cat</code>
    * **Arguments**: <code>[path/to/filename, filename]</code>
    * **Options**: <code>None</code>
    * **Output**:
        * the contents of the file (assume files contain just text)
4. <code>mkdir</code>
    * **Arguments**: <code>[path/to/dir, dirname]</code>
    * **Options**: <code>None</code>
    * **Result**:
        * create a directory under the given path if the <code>dirname</code> of directory does not present
5. <code>write</code>
    * **Arguments**: <code>[path/filename, content]</code>
    * **Options**: <code>None</code>
    * **Result**:
        * overwrite the file by given content if the <code>filename</code> exists, otherwise create a new file named <code>filename</code> with <code>content</code>

⚠️⚠️ ⚠️   since you are not going to implement <code>cd</code>, __every path in the argument list__ is an __ABSOLUTE PATH__.

#### In-memory File System

Now, you'll implement the in-memory file system in <code>FileSystem.js</code> by encapsulating the **state of file system** and __methods__ for manipulating it.

When the server is initialized (that is, before it starts listening on a port)g, it instantiates this object with a given initial state of the file system. While the server is running, it dispatches the client's requested actions to methods and modifies or reads the state of the file system. Consequently, the majority of your file system logic will live in a class rather than within the route handling functions of your Express application.

##### Initial State of File System

You'll be given a javascript file `init.josn` containing the initial structure of the file system. 

The structure of a file system is represented using a nested JSON object. A nested JSON object is a structure of an arbitrary tree. A file is a node of this tree and also a key-value pair in a JSON object.

The basic information of a node (file) is listed below.


#### Directory
```
'dir-name': {
    'permission': file type and file mode (drwxr--r--),
    'hard-links': arbitrary number,
    'owner-name': arbitrary string,
    'owner-group': arbitrary string,
    'last-modified': use momentJS,
    'size': arbitrary number,
    'files': {
        // a nested structure of more directories or files as JSON objects
    },
}
```

##### File
```
'file-name': {
            'permission': '-rwxr--r--',
            'hard-links': 1,
            'owner-name': 'root',
            'owner-group': 'root',
            'last-modified': use momentJS,
            'size': 6,
            'content': 'Hello World!'
        }
```

A snapshot of the file system looks like the example below. 

```javascript=
'/':{
    'permission': 'drwxr--r--',
    'hard-links': 1,
    'owner-name': 'root',
    'owner-group': 'root',
    'last-modified': moment().format('MMM DD HH:mm'),
    'size': 6,
    'files': {
        'bin': {
            'permission': 'drwxr--r--',
            'hard-links': 1,
            'owner-name': 'root',
            'owner-group': 'root',
            'last-modified': moment().format('MMM DD HH:mm'),
            'size': 6,
            'files': {
            }
        },
        .... More files ...
```

##### The File System Class

Now, you'll implement this file system using a class in Javascript. Create a file `fileSystem.js` and implement this class. Please note that you can implement the file system using your own design, but these are some suggestions:

1. <code>constructor</code>
    * This is the link to the initial state of file system [](), now require this JSON object and initiate a property with this JSON object in your class constructor.
    * If you are using function expression instead of arrow functions, bind your methods with <code>this</code> of the class here
2. <code>find</code>
    * **Arguments**: <code>[path/to/file]</code>
    * **Description**: traverse the file system tree to find the file or directory. After the file or directory is found, return the JSON object representing the file system subtree rooted at this file or directory. This method should also record parent directory during traversal. After the file is found, put metadata of current and parent files into the returned JSON object. 
3. <code>traverseAndList</code>
    * **Arguments**: <code>[path/to/file]</code>
    * **Description**: this method is for <code>ls</code> command. If the path points to a directory, return a list of JSON object representation of the files under this directory. Otherwise, return an empty list.
4. <code>makeDirectory</code>
    * **Arguments**: <code>[path/to/dir, directory name]</code>
    * **Description**: first call find to get the JSON object of <code>dir</code>, then create a new entry in this directory. The file type is directory. Other metadata could be arbitrary.
    * **Requirements**:
        * The file type should be `d`
        * The last-modified-date should be generated by `momentJS` with date format `MMM DD HH:mm`
        * The name of key to store direcotries and files should be `files`
        * Others can be arbitrary
5. <code>cat</code>
    * **Arguments**: <code>[path/to/file]</code>
    * **Description**: return the content of the file if it is a file, otherwise return error messages (e.g., cat: No such file or directory)
6. <code>write</code>
    * **Arguments**: <code>[path/to/file, content]</code>
    * **Description**: use find to get the JSON object of the **directory** on given path (HINT: use file type in the permission string). If the file exists, overwrite it by <code>content</code>. Otherwise create a new entry in this object with key equals given file name and content written (remember the name of new entries should be different from any name of key in the JSON).
    * **Requirements**:
        * The file type should be `-`
        * The last-modified-date should be generated by `momentJS` with date format `MMM DD HH:mm`
        * The name of key to store file content should be `content`
        * Others can be arbitrary

Following class is an example to implement this file system. You are not required to follow this class definition.

```javascript=
class FileSystem {
    constructor () {
        // Provided by initFs.js
        this.fs = fs;
    }

    find(path) {
        /*    Params:  query path.
         *    Example:
         *       /path/to/this/file
         *       ['', 'path', 'to', 'this', 'file']
         */
    }

    traverseAndList(path) {
        /* Params:
         *    A list of directoies destructured from the path.
         */
    }

    makeDirectory(path, dirName) {
        /* Params:
         *    A list of directoies destructured from the path,
         *    the directory name that is going to create
         *    Example:
         *       /path/to/this/file
         *       ['', 'path', 'to', 'this', 'file']
         */
    }

    cat(path) {
        /* Params:
         *    A list of directoies destructured from the path.
         *    Example:
         *       /path/to/this/file
         *       ['', 'path', 'to', 'this', 'file']
         */
    }

    write(path, content) {
        /* Params:
         *    A list of directoies destructured from the path,
         *    and the content ready to be written to the file
         *    Example:
         *       /path/to/this/file
         *       ['', 'path', 'to', 'this', 'file']
         */
    }
}
```


### Express Server

In this section, you'll implement an Express server that interact with a file system you built in the previous section.

#### Setup / Middleware

* Create a basic express application called <code>app.js</code>
	* make sure that your application is __served over port 3000__
* Add below middleware to your app
    * <code>express.urlencoded</code> (this is a built-in middlware function; no installation needed): this will help you parse the body in <code>POST</code> requests
	* see [the slides on POST forms for setup](../slides/10/forms.html#/6)
* Serve static files:
	* check out the [slides on serving static files with Express](../../slides/08/express.html#/29)
    * test that both the css files and image work after running <code>app.js</code>
        * for example, try to curl <code>http://localhost:3000/img/ubuntu.jpg</code> or go that url in your browser
* Import a class from the module <code>fileSystem.js</code>
* Enable <code>Handlebars</code> for templating in the later section

#### Route
In this section, you'll implement callback handlers to server browser requests. There are two routes you'll build: __<code>/</code> and <code>/vfs</code>__ You are required to serve GET and POST requests using __only one Url: <code>/vfs</code>__. 

A Url is a resource identifier and the resource in this homework is our virtual file system. The semantic here is using HTTP verbs to manipulate the file system located at <code>/vfs</code>.

<code>GET</code> requests:

* <code>/</code>: renders an index page <code>index.hbs</code>
* <code>/vfs</code>:
    * Receives three parameters <code>command</code>, <code>path</code>, <code>option</code>
    * Parse <code>path</code> appropriately, call <code>find</code> method defined in <code>fileSystem</code> object
    * Call appropriate methods in the class given by <code>command</code>
    * Use <code>option</code> parameters if necessarily
    * Render an appropriate HTML page and pass a context containing the information retrieve from the file system

<code>POST</code> requests

* <code>/vfs</code>
    * Receive three parameters <code>command</code>, <code>path</code>, <code>content</code>
    * Parse <code>path</code> appropriately, call <code>find</code> method defined in <code>fileSystem</code> object
    * Call appropriate methods in the class given by <code>command</code>
    * Use <code>option</code> parameters if necessarily
    * Render an appropriate HTML page and pass a context containing the message showing success or not


### Templating

In this part, you'll work with HTML and templating to build your front-end. You'll also use the context passed from the server to render partial templates. You don't have to implement the interface exactly the same as examples provided (styling is not strictly required). But basic pages for a functional system are required. __You are free to style your app using any approach. Following description is based on the demo as an example for explaining goals of this part.__

* Set up handlebars - [these slides](../../slides/09/templating.html) 
	* Get all the requirements and config setup
	* Create the appropriate views folder, along with an initial layout file:
		* <code>views</code>
        * <code>views/layout.hbs</code>

In <code>layout.hbs</code>

* Create a title tag with text <code>OS</code>
* Create appropriate tags inside <code>head</code>
* Create <code>body</code> tag
* Link your <code>style.css</code> stylesheet
    * A basic <code>style.css</code> is provided, you can modify it if you want a different style

#####  Creating a Home Page

The home page consists of a dropdown menu with options for users to select different types of styling in the next page. The styling should be different from each othe and can be implemented through CSS or images. The goal is to retrieve multiple static files from the server.

Your app should receive <code>GET</code> requests on the path, <code>/</code>. Server responds by rendering templates.

* In your <code>index.hbs</code>
    * Create a form with attributes below
        1. <code>action="http://localhost:3000/vfs"</code> (may be different if the server listens on other ports)
        2. <code>method="get"</code>
    * In this form, create a <code>select</code> dropdown with:
        1. a <code>name</code> attribute
        2. three <code>option</code> with <code>value</code> and <code>text</code> equal to the name of selected operating system
    * Lastly, create a <code>button</code> with <code>type</code> of submit
    * Send this form to get the Url of static files and used them in the next page
    * Below is an example for selecting three OS distributions in the next page <code>terminal.hbs</code>

<div markdown="block" class="img">
<img src='../resources/img/hw04-file-system-homepage.png' width="100%">
<img src='../resources/img/hw04-file-system-homepage-dropdown.png' width="100%">
</div>


##### Creating two forms for submitting commands and arguments

In the <code>terminal.hbs</code>, we want to manipulate the file system by using forms and display styles based on the selection of previous page: <code>/</code>. Following demonstrates basic forms. __(HINT: pass additional information to server for requesting static files without showing extra information of two forms)__

* Create a <code>GET</code> form
    1. <code>action="http://localhost:3000/vfs"</code> (may be different if the server listens on other ports)
    2. <code>method="get"</code>
    3. In this form, add three HTML input tags: <code>command</code>, <code>option</code>, and <code>path</code>
    4. Add a submit button with type of <code>submit</code>
    5. Note that this form shares the same Url with homepage form
* Create a <code>POST</code> form
    1. <code>action="http://localhost:3000/vfs"</code> (may be different if the server listens on other ports)
    2. <code>method="post"</code>
    3. In this form, add three HTML input tags: <code>command</code>, <code>path</code>, and <code>content</code>
    4. Add a submit button with type of <code>submit</code>
* Use static files (css, images) to style your pages 

* Examples would look like below.
<div markdown="block" class="img">
<img src="../resources/img/hw04-file-system-ubuntu.png" width="100%">
<img src="../resources/img/hw04-file-system-debian.png" width="100%">
</div>

##### Create an area (terminal) where displaying messages sent from the server

For each command, the server responds with the state of file system wrapped in a context object. In this section, you'll display each information in the context object by using some templating syntax and techniques __(HINT: you'll use HBS tempalte syntax for iterating an array, an array of objects, and an object. If statement will also be used)__.

* <code>ls</code>
    1. The server is supposed to pass files and directories in the form of a list of JSON objects.
    2. Display each file or directory in one line with <code>file_type, permissions, number of hard links, owner, group, size, last-modified data, file name</code>
    3. If the path cannot be found, output `ls: No such file or directory`
    4. Example:
        without <code>-l</code> option
        <div markdown="block" class="img">
        <img src="../resources/img/hw04-file-system-ls.png" width="100%">
        with <code>-l</code> option
        <div markdown="block" class="img">
        <img src="../resources/img/hw04-file-system-ls-l.png" width="100%">
        </div>
* <code>tree</code>
    1. The server is supposed to pass the entire file system object
    2. You don't have to display it in a tree structure. Any way of showing the hierarchy would be accepted.
    3. If you would like to create a tree-like directory, please refer to <code>partials</code> to recursively generate a tree-like view
    4. If the directory cannot be found, output `tree: No such file or directory`
    5. Example:
        <div markdown="block" class="img">
        <img src="../resources/img/hw04-file-system-tree.png" width="100%">
        </div>
* <code>cat</code>
    1. The server is supposed to respond the content of the file (a string).
    2. If the file cannot be found, output `cat: No such file or directory`
    3. Example:
        <div markdown="block" class="img">
        <img src="../resources/img/hw04-file-system-cat.png" width="100%">
        </div>
* <code>mkdir</code>
    1. The server is supposed to respond a list of files and directories after the directory is created
    2. If the directory already exists, output `mkdir: ${dirName} : File exists`
    3. After create a directory <code>Hi</code>
    <div markdown="block" class="img">
    <img src="../resources/img/hw04-file-system-af-mkdir.png" width="100%">
    </div>
* <code>write</code>
    1. If success, not required to display any messages. But make sure the content is written to the file by using <code>cat</code>
    2. If failed, output `write: No such file or directory`

</div>

</div>
